// Raider.h + Raider.cpp + RaiderAIController.h/.cpp combined
// Drop into your project and split into .h/.cpp files if needed (editors note)

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "Perception/PawnSensingComponent.h"
#include "Raider.generated.h"

UCLASS()
class STRONGHOLDSURVIVAL_API ARaider : public ACharacter
{
    GENERATED_BODY()

public:
    ARaider();

protected:
    virtual void BeginPlay() override;
    virtual void Tick(float DeltaTime) override;

    // === Raider Stats ===
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider")
    float Health;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider")
    float AttackDamage;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider")
    float DetectionRadius;

    // === Animation References ===
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* IdleAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* WalkAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* RunAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* AttackAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* HowlAnim;

    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Raider|Animations")
    UAnimationAsset* BlockBreakAnim;

    // === State Flags ===
    bool bHasTarget;
    bool bIsAttacking;
    bool bIsHowling;

    // === Components ===
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="Raider")
    UPawnSensingComponent* PawnSensingComp;

    // === Functions ===
    void PerformAttack();
    void PerformHowl();
    void BreakBlock(AActor* BlockActor);
    void TriggerGroupAggro();
    void TrackPlayer();
    void Die();

    // Callback when player is sensed
    UFUNCTION()
    void OnSeePawn(APawn* Pawn);

    // Timer handle for howl cooldown
    FTimerHandle HowlCooldownHandle;
};

// ================= Implementation =================

#include "Raider.h"
#include "RaiderAIController.h"
#include "Kismet/GameplayStatics.h"
#include "Engine/Engine.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "Components/SkeletalMeshComponent.h"
#include "AIController.h"

// Example Block base class
UCLASS()
class STRONGHOLDSURVIVAL_API ABlock : public AActor
{
    GENERATED_BODY()

public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Block")
    FString BlockType; // "Wood", "Nature", "Stone"
};

ARaider::ARaider()
{
    PrimaryActorTick.bCanEverTick = true;

    Health = 100.f;
    AttackDamage = 20.f;
    DetectionRadius = 1500.f; // ~15 blocks

    bHasTarget = false;
    bIsAttacking = false;
    bIsHowling = false;

    PawnSensingComp = CreateDefaultSubobject<UPawnSensingComponent>(TEXT("PawnSensingComp"));
    PawnSensingComp->SightRadius = DetectionRadius;
    PawnSensingComp->SetPeripheralVisionAngle(60.f);
    PawnSensingComp->OnSeePawn.AddDynamic(this, &ARaider::OnSeePawn);
}

void ARaider::BeginPlay()
{
    Super::BeginPlay();
    if (IdleAnim)
        GetMesh()->PlayAnimation(IdleAnim, true);
}

void ARaider::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    if (bHasTarget) TrackPlayer();
}

void ARaider::OnSeePawn(APawn* Pawn)
{
    if (!bHasTarget && Pawn->IsPlayerControlled())
    {
        bHasTarget = true;
        PerformHowl();
    }
}

void ARaider::TrackPlayer()
{
    ACharacter* Player = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);
    if (!Player) return;

    float Dist = FVector::Dist(Player->GetActorLocation(), GetActorLocation());

    AAIController* AICon = Cast<AAIController>(GetController());
    if (AICon)
    {
        AICon->MoveToActor(Player);
    }

    if (Dist > 600.f) // run if far
    {
        GetCharacterMovement()->MaxWalkSpeed = 500.f;
        if (RunAnim) GetMesh()->PlayAnimation(RunAnim, true);
    }
    else // walk if close
    {
        GetCharacterMovement()->MaxWalkSpeed = 300.f;
        if (WalkAnim) GetMesh()->PlayAnimation(WalkAnim, true);
    }
}

void ARaider::PerformAttack()
{
    bIsAttacking = true;
    if (AttackAnim)
        GetMesh()->PlayAnimation(AttackAnim, false);

    ACharacter* Player = UGameplayStatics::GetPlayerCharacter(GetWorld(), 0);
    if (Player)
    {
        UGameplayStatics::ApplyDamage(Player, AttackDamage, GetController(), this, nullptr);
    }

    bIsAttacking = false;
}

void ARaider::PerformHowl()
{
    if (bIsHowling) return;
    bIsHowling = true;

    if (HowlAnim)
        GetMesh()->PlayAnimation(HowlAnim, false);

    if (GEngine)
        GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("RAIDERS INCOMING BEWARE"));

    TriggerGroupAggro();

    GetWorldTimerManager().SetTimer(HowlCooldownHandle, [this]()
    {
        bIsHowling = false;
    }, 10.f, false);
}

void ARaider::TriggerGroupAggro()
{
    TArray<AActor*> NearbyRaiders;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ARaider::StaticClass(), NearbyRaiders);

    for (AActor* Actor : NearbyRaiders)
    {
        ARaider* Raider = Cast<ARaider>(Actor);
        if (Raider && Raider != this)
        {
            float Dist = FVector::Dist(Raider->GetActorLocation(), GetActorLocation());
            if (Dist <= DetectionRadius)
            {
                Raider->bHasTarget = true;
            }
        }
    }
}

void ARaider::BreakBlock(AActor* BlockActor)
{
    if (!BlockActor) return;

    ABlock* Block = Cast<ABlock>(BlockActor);
    if (Block)
    {
        if (Block->BlockType == "Wood" || Block->BlockType == "Nature")
        {
            if (BlockBreakAnim)
                GetMesh()->PlayAnimation(BlockBreakAnim, false);

            BlockActor->Destroy();
        }
        else
        {
            if (GEngine)
                GEngine->AddOnScreenDebugMessage(-1, 3.f, FColor::Silver, TEXT("Raider cannot break stone blocks!"));
        }
    }
}

void ARaider::Die()
{
    Destroy();
}

// ================= RaiderAIController =================

#pragma once

#include "CoreMinimal.h"
#include "AIController.h"
#include "RaiderAIController.generated.h"

UCLASS()
class STRONGHOLDSURVIVAL_API ARaiderAIController : public AAIController
{
    GENERATED_BODY()

public:
    virtual void OnPossess(APawn* InPawn) override;
};

#include "RaiderAIController.h"
#include "Raider.h"

void ARaiderAIController::OnPossess(APawn* InPawn)
{
    Super::OnPossess(InPawn);
    ARaider* Raider = Cast<ARaider>(InPawn);
    if (Raider)
    {
        // Raider starts idle until it sees player
    }
}
